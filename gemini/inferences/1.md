# Inferred Project Goals and Developer Preferences

This document summarizes the key goals and preferences inferred from our development session. It should be used as a guiding context for all future work on this project.

## Core Principles

1.  **Primary Goal: A Professional & Polished UI/UX**
    - The end product must be more than just functional. It must have a "beautiful," "delightful," and "professional" look and feel.
    - User-facing features should be intuitive, discoverable, and adhere to common UX patterns (e.g., clickable headers, sort icons).

2.  **Developer Experience (DX) is a Top Priority**
    - **Minimal Boilerplate:** The API design should strive for the lowest possible friction for the developer. We should actively seek ways to reduce repetitive code, such as providing type-safe helpers (`SortPlugin.comparers`).
    - **Type Safety & IDE Support:** Leveraging TypeScript to its fullest is crucial. The goal is to catch errors at compile time and provide rich IDE autocompletion to make development faster and more reliable.
    - **Concise & Readable API:** The public API should be elegant, self-documenting, and easy to reason about.

3.  **Robust & Extensible Architecture**
    - **Separation of Concerns:** The plugin-based architecture is a core design principle. The base component should remain lean, with new functionality encapsulated in discrete, reusable plugins.
    - **Backward Compatibility is Non-Negotiable:** All new features must be implemented as non-breaking changes. Existing users should be able to upgrade without any issues.
    - **Opt-In Features:** New functionality should be "opt-in" rather than "opt-out" to ensure the API is intentional and predictable.

4.  **Comprehensive & Accurate Documentation**
    - The `README.md` is the single source of truth for developers using the library.
    - It must be kept in perfect sync with the codebase.
    - Documentation should be comprehensive, providing clear, practical, and extensive examples for all features and their configurations.

5.  **Structured & Methodical Workflow**
    - We follow a deliberate, multi-step process for feature development and releases:
        1.  **Discuss:** Thoroughly explore the requirements, goals, and potential edge cases.
        2.  **Plan:** Agree on a detailed, robust implementation plan before writing any code.
        3.  **Implement:** Execute the plan.
        4.  **Document:** Fully document the new feature and update all relevant parts of the `README.md`.
        5.  **Release:** Only after the feature is implemented and documented do we proceed with the formal release process.

---

## Meta-Workflow: Context & Inference Management

This section outlines my process for gathering and maintaining context across our development sessions.

### How to Gain Full Context

To gain full inference and context from a session, I must not only process the explicit instructions but also synthesize the underlying goals and preferences that drive them. This involves:

1.  **Active Listening:** Paying close attention to the specific vocabulary used (e.g., "professional," "delightful," "boilerplate," "type-safe"). These keywords are signals of the project's core values.
2.  **Identifying Patterns:** Recognizing recurring themes in the feedback. For example, the repeated emphasis on minimizing boilerplate and maximizing type safety indicates a strong preference for a clean, modern developer experience.
3.  **Connecting the Dots:** Understanding how a high-level goal (e.g., "a professional look") translates into specific, actionable implementation details (e.g., CSS-based icons, smooth transitions, clear visual states).
4.  **Synthesizing the "Why":** Moving beyond the "what" of a request to understand the "why." The goal isn't just to add a sort function; it's to add a sort function *that feels like it belongs* in a high-quality component library.

### Saving Context for Future Sessions

-   **Timing:** Just before a major step like a release, I will reveal the new general information I have gathered about preferences, goals, and project ambitions.
-   **Offer to Save:** I will offer to save this new context into the `gemini/inferences/` directory.
-   **Incremental Naming:** I will propose saving the new context in the next available numbered file (e.g., `1.md`, `2.md`, etc.) to create a chronological record of our evolving project philosophy.
-   **Third-Party Readability:** All newly gathered inferences will be written in a way that is explicitly targeted to a third party who does not have the context of our chat. This means:
    -   Inferences will be broad and explicit enough, with sufficient examples and scenarios, to fully bring the third party up to speed.
    -   They will avoid shallow references to our specific discussions and instead focus on generalizable principles and observations.
